![[Pasted image 20240115172636.png]]
In the provided code snippets, there are differences in the function `set` and how it's called in the `main` function. Let's go through each snippet:

### First Code Snippet:
```c
void set(int* p, int* v) {
    p = v;
}

int main() {
    int i = 3;
    int* pi = NULL;
    set(pi, &i);
    printf("*pi: %d\n", *pi);
}
```

In this snippet:
- The `set` function takes two parameters, `p` (a pointer) and `v` (a pointer).
- Inside `set`, the local pointer `p` is assigned the value of `v`, but this assignment only affects the local copy of `p` within the function, not the pointer `pi` in `main`.
- The `main` function prints the dereferenced value of `pi`, but since `pi` was not modified within the `set` function, it remains `NULL`, and dereferencing it leads to undefined behavior.

### Second Code Snippet:
```c
void set(int** p, int* v) {
    *p = v;
}

int main() {
    int i = 3;
    int* pi = NULL;
    set(&pi, &i);
    printf("*pi: %d\n", *pi);
}
```

In this snippet:
- The `set` function takes two parameters, `p` (a pointer to a pointer) and `v` (a pointer).
- Inside `set`, the content of the pointer pointed to by `p` is assigned the value of `v`. This effectively modifies the value of `pi` in the `main` function.
- The `main` function prints the dereferenced value of `pi`, and since `set` modified the content of `pi`, it prints the value of `i` (which is `3`).

### Key Difference:
- The key difference is in the type of the `p` parameter in the `set` function and how it is used. In the first snippet, `p` is a pointer, and the assignment `p = v;` only affects the local copy of `p` within the function. In the second snippet, `p` is a pointer to a pointer, and the assignment `*p = v;` modifies the content of the pointer pointed to by `p`, affecting the variable `pi` in the `main` function.

In summary, the second code snippet correctly modifies the value of `pi` in the `main` function, whereas the first code snippet does not modify the value of `pi` because the pointer is passed by value.



The two code snippets you provided demonstrate two different ways of passing parameters to a function in C. Let's break down the differences between the two:

### First Code Snippet:
```c
void add(int value, int increment) {
    value += increment;
}

int main() {
    int i = 3;
    add(i, 4);
    printf("i: %d\n", i);
}
```

In this snippet:
- The `add` function takes two integers `value` and `increment` by value.
- The `main` function calls `add` with `i` and `4`. However, changes made to `value` inside `add` are local to the function, and the original `i` in `main` remains unchanged.

### Second Code Snippet:
```c
void add(int *value, int increment) {
    *value += increment;
}

int main() {
    int i = 3;
    add(&i, 4);
    printf("i: %d\n", i);
}
```

In this snippet:
- The `add` function takes an integer pointer `value` and an integer `increment`. It modifies the value pointed to by `value`.
- The `main` function calls `add` with the address of `i` (`&i`) and `4`. This means that `add` can directly modify the content of `i`.
- The `printf` statement in `main` will output the modified value of `i`.

### Key Difference:
- In the first snippet, the `add` function takes parameters by value, so changes made to `value` inside the function do not affect the original variable `i` in `main`.
- In the second snippet, the `add` function takes a pointer to `value`, allowing it to modify the original variable `i` by dereferencing the pointer.

In general, when you need a function to modify the value of a variable and have the changes reflected outside the function, you should pass the address of the variable (using pointers). The second code snippet is a more common pattern when you want a function to modify the value of a variable.![[Pasted image 20240115172632.png]]