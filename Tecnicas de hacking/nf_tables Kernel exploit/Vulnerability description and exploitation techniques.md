
- Anonymous sets are those that are:m

	- Bound to a rule, if the rule is removed, that set is released too.
	- They have no specific name, the kernel internally allocates an identifier.
	- They cannot be updated. So you cannot add and delete elements from it once it is bound to a rule.
	- 
https://github.com/oferchen/POC-CVE-2023-32233
https://anatomic.rip/netfilter_nf_tables/
https://access.redhat.com/documentation/de-de/red_hat_enterprise_linux/8/html/configuring_and_managing_networking/getting-started-with-nftables_configuring-and-managing-networking

The vulnerability is located in the Netfilter nf_tables component of the official Linux kernel. Specifically, when updating the configuration using atomic operations, a batch request containing a delete rule operation (NFT_MSG_DELRULE) and a delete set element operation (NFT_MSG_DELSETELEM) can lead to memory corruption. The issue arises due to insufficient checks during the processing of the batch, allowing for the manipulation of memory locations.

Exploiting this vulnerability involves racing with the background worker thread executing nf_tables_trans_destroy_work(). By carefully timing operations, an attacker can modify the content of deallocated memory between nf_tables_rule_destroy() and nf_tables_set_elem_destroy(). This allows for the corruption of the nft_set_ext structure, leading to type confusion.

To achieve reliable exploitation, the attacker introduces controlled delays for the background worker thread by adding additional operations to destroy another nft_set. By keeping other CPU cores busy, the attacker increases the likelihood of the background worker thread being scheduled on a specific core, enabling the allocation of a new structure from the same core. The goal is to allocate a new nft_set with a different type, causing the memory location of the deallocated nft_set to be reused.

The type confusion is then abused by crafting corrupted nft_set_ext headers with out-of-range offsets. This leads to the misinterpretation of memory blocks as a list of nft_expr structures during the execution of nf_tables_set_elem_destroy(). Through careful manipulation, the attacker can call expr->ops->destroy() on certain valid nft_expr in adjacent memory chunks, achieving type confusion.

The attacker leverages the type confusion to exploit the kernel. They use nft_log expressions with controlled NFTA_LOG_PREFIX to spray memory, and once expr->ops->destroy() is called, the associated nft_log->prefix is deallocated. The attacker can access and deallocate this memory again through another reference, achieving control over the memory content.

The attacker further exploits the vulnerability by controlling the size of nft_log->prefix, allocating nft_object->udata to reuse nft_log->prefix memory. This allows the attacker to leak memory content without restrictions on NULL bytes.

In the final steps, the attacker targets nft_expr structures allocated from nft_dynset_new(). These structures reside in the same slabs as nft_log->prefix and nft_object->udata, providing reasonable control over allocation size. By creating a packet filter with nft_dynset expression, the attacker triggers nft_dynset_new() to create new elements for the associated nft_set. These elements include nft_counter for obtaining the location of nf_tables.ko in kernel memory and nft_quota for arbitrary memory read and write.

Using arbitrary memory read, the attacker obtains the base address of the kernel core and proceeds to modify the "sbin" substring of "/sbin/modprobe" pathname. This replacement results in the pathname "//tmp/modprobe," which the kernel uses to start a process with root privileges, allowing the attacker to control the file content.

The exploit seems to avoid intentional efforts to bypass Control-Flow Integrity (CFI), relying on flexible and robust primitives for each step. The attacker expresses curiosity about confirming the exploit's effectiveness against systems with CFI mitigations through testing.